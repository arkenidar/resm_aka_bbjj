<a href="https://github.com/arkenidar/resm_aka_bbjj">https://github.com/arkenidar/resm_aka_bbjj</a> <br>
Raw Execution-Step Machine also known as Bit Bit Jump Jump machine <br>
Simple computer design. Files and ideas, documentation to the concept of BitBitJump machine, extended, popularized, applied. <br>
My explorations of "Bit Bit Jump Jump" *uniform instruction set* CPU design. <br>
<ul>
<li>A few introductory words</li>
<li>Attached file (Logisim-based simulable schematics and Violet-based flow-chart)</li>
<li>Rediscovery of this machine design</li>
<li>Circuital schematics</li>
<li>Documentation for circuital schematics and abstract concept of Bit Bit Jump Jump machine</li>
<li>More informations on this machine, with further exploration directions and ideas</li>
<li>Bit Bit Jump Jump programs and its interpreter</li>
<li>Flow-charts of Bit Bit Jump Jump programs</li>
<li>Answers to Common question a.k.a. FAQ</li>
</ul>
<h2>A few introductory words</h2>
<p>[IT] concetto di computer minimo, avente istruzioni uniformi, implementato con circuito (hardware) e con interprete di questo tipo di istruzioni (software) </p>
<p><strong>[EN]</strong> concept of minimal computer, having uniform instructions, implemented with circuits (<strong>hardware</strong>) and with interpreter of this type of instructions (<strong>software</strong>)</p>
<h2><a href="https://github.com/arkenidar/resm_aka_bbjj/archive/master.zip" target="_blank">Attached file (Logisim-based simulable schematics and Violet-based flow-chart)</a></h2>
<h4><em>I did put together some <strong>documentation</strong> and <strong>interactive material</strong> about my <span style="text-decoration: underline;">Explorations of Bit Bit Jump Jump "uniform instruction set" CPU design</span>. This design is a direct application of <strong>Turing Machines</strong> and <strong>flow-charts</strong>, and is able to show its validity across centuries if given the chance, since <strong>it is the quintessence of binary computing</strong>. </em></h4>
<h2>Rediscovery of this machine design</h2>
<p>I would like to pass on this knowledge so other people may experiment and re-apply the knowledge and wisdom contained herein. My only role and merit could be having documented a little bit the already existing BitBitJump design, but this is not to be underestimated because precious knowledge tend to be lost in time if not valued and actively preserved.</p>
Possibly, with sufficient resources <strong>this design can be rediscovered</strong>, as I did for example. I have used again the more popular name "Bit Bit Jump Jump Machine", but if I had to choose a <strong>new name</strong> I would have labeled this machine design: <em><strong>R.E.S.M. </strong></em>(<strong>R</strong>aw <strong>E</strong>xecution-<strong>S</strong>tep <strong>M</strong>achine). The rest of the paragraph is more theoretical, I hope no one is hurt by these words <strong>;)</strong>. This design features <strong>energetic transference and pathways formation</strong>, found in many other systems, including neural living systems, but this machine is not so similar to living systems, as the program (and pathways definition) is constant in time. However programs can be executed using different paths. Energy transference can happen in this machine, of course, whenever a bit copy is done.
<h2>Circuital schematics</h2>
Use <a href="http://www.cburch.com/logisim/" target="_blank"><strong>Logisim</strong></a> (<a href="http://www.cburch.com/logisim/" target="_blank">http://www.cburch.com/logisim/</a>).<br /><em>Logisim is a <strong>circuit design and emulation software</strong>,</em><br />&nbsp;<strong>free</strong> and open source,<br />&nbsp;cross-platform because it is written in Java+Swing,<br />&nbsp;<strong>works on all major platforms</strong> including Windows and Linux and Mac OS.<br /><br /><a href="https://github.com/arkenidar/resm_aka_bbjj/archive/master.zip" target="_blank">Logisim file from me for BitBitJumpJump CPU. It is missing proper I/O (using simulator features for I/O into/from memories)</a><br /><a href="https://github.com/arkenidar/resm_aka_bbjj/raw/master/circuits_in_logisim/circuit_schematics.png" target="_blank"><img src="https://github.com/arkenidar/resm_aka_bbjj/raw/master/circuits_in_logisim/circuit_schematics.png" alt="Logisim file for BitBitJumpJump CPU. It is missing proper I/O (using simulator features for I/O into/from memories)" border="0" /></a>
<h2>Documentation for circuital schematics and abstract concept of Bit Bit Jump Jump machine</h2>
The circuits executes endlessly instructions (no halting in current design). Every instruction is composed of <strong>four operands</strong> (COPY_FROM, COPY_TO, IP_CASE_0, IP_CASE_1). Every instruction is executed in <strong>3 phases</strong>. In <strong>phase 1</strong> the bit pointed by the COPY_FROM register is fetched. Then in <strong>phase 2</strong> the fetched bit is written in the memory location pointed by COPY_TO. This is the bit copying, "Bit Bit" part of the BitBitJumpJump instruction type. In <strong>phase 3</strong>, the "Jump Jump" part, the registers IP_CASE_0 and IP_CASE_0 are used to specify where to jump, selecting the next instruction. If Program Path Selector (PPS) is 0 the <strong> IP</strong> (Instruction Pointer) will have the value contained in IP_CASE_0, otherwise, for PPS=1: IP &lt;- IP_CASE_1 (IP will have the value of the associated register). PPS register can be written when the destination (COPY_TO register) is equal to 0x02 (third bit of RAM, RAM has single-bit words, this is a feature possible in Logisim). So <strong>copy by copy, and path selection by path selection the program processes data</strong>. I/O is usually implemented using a special Input memory location and a special Output memory location. I will do that ASAP, for now I am using the simulator ways to insert bits and to show bits.<br /><br />
<h2>More informations on this machine, with further exploration directions and ideas</h2>
The "Bit Bit Jump Jump machine/CPU" is <strong>Turing complete</strong>, so it is a matter of coding the proper instructions but every computation can be done. <strong>This concept of computational machine is very educational and straight to the essence, and should be more commonly and widely known.</strong> I intending to document and to spread knowledge and I hope this will be successful and appreciated in due time, by wise people who can reap the wisdom of this beautifully simple design and concept. This machine has no concept of "words", so it is not 32 or 64 bit but words can be composed of an arbitrary number of bits, given a proper quantity of associated instructions. This is another beautiful feature of the essentialness of this design. More to come: stay tuned! One last word: this extremely expanded way to describe computation is useful for <strong>rewriting programs</strong> in different ways, e.g. <strong>size-optimizing programs</strong>, in a very <strong>granular</strong> and thorough way. Some one has used this way to <strong>obfuscate programs</strong> (and that is a kind of rewrite certainly) but the real deal AFAIK will be experimenting code-optimizations by code-rewriting. Also this is an abstract representation that could possibly be used as an intermediary representation when <strong>converting a program code from one format to another</strong>, e.g. in case of porting from a CPU architecture to another. Indeed every program is the equivalent of a <strong>flowchart</strong> where every instruction is an assignment activity (<strong>rectangular shape</strong>) followed a decision (<strong>diamond shape</strong>). So again you can shape this at will and write any kinds of programs (I/O is made this way: for input "var &lt;- in" activity and for output "out &lt;- var" activity).<br />
<h2>Bit Bit Jump Jump programs and its interpreter</h2>
A JavaScript-based version from me: <a href="https://jsfiddle.net/devdev/og526zfw/4/" target="_blank">Bit Bit Jump Jump programs and interpreter using web standards</a>.

<h2>Flow-charts of Bit Bit Jump Jump programs</h2>
Use <strong><a href="https://sourceforge.net/projects/violet/" target="_blank">Violet</a></strong> (<a href="https://sourceforge.net/projects/violet/" target="_blank">https://sourceforge.net/projects/violet/</a>).<br /><em>Violet is a UML Editor, you can <strong>draw flow-charts and more</strong>,</em><br />&nbsp;<strong>free</strong> and open source,<br />&nbsp;cross-platform because it is written in Java,<br />&nbsp;<strong>works on all major platforms</strong> including Windows and Linux and Mac OS.<br /><br />
<a href="https://github.com/arkenidar/resm_aka_bbjj/archive/master.zip" target="_blank">Violet files from me for program flow-charts. Programs: not gate, or gate.</a>

<h3>Flow-chart of "NOT gate" Bit Bit Jump Jump program</h3>
<a href="https://github.com/arkenidar/resm_aka_bbjj/raw/master/flowcharts_in_violet/flowchart_of_not_gate_program.png"
alt="Flow-chart of &amp;quot;NOT gate&amp;quot; Bit Bit Jump Jump program">
<img src="https://github.com/arkenidar/resm_aka_bbjj/raw/master/flowcharts_in_violet/flowchart_of_not_gate_program.png"
alt="Flow-chart of &amp;quot;NOT gate&amp;quot; Bit Bit Jump Jump program"
/></a>
<br />

<h3>Flow-chart of "OR gate" Bit Bit Jump Jump program</h3>
<a href="https://github.com/arkenidar/resm_aka_bbjj/raw/master/flowcharts_in_violet/flowchart_of_or_gate_program.png"
alt="Flow-chart of &amp;quot;OR gate&amp;quot; Bit Bit Jump Jump program">
<img src="https://github.com/arkenidar/resm_aka_bbjj/raw/master/flowcharts_in_violet/flowchart_of_or_gate_program.png"
alt="Flow-chart of &amp;quot;OR gate&amp;quot; Bit Bit Jump Jump program"
/></a>

<h2>Answers to Common question a.k.a. Frequently Asked Questions</h2>
<ul>
<li><em>Is this a Turing machine?</em> Answer: No, because it has at least one difference: Turing machine has a tape so the next instruction could be the previous or the following position (contiguous access a.k.a. linear access) in the tape. In this design the next instruction could be any instruction, including the current instruction (<strong>arbitrary access</strong> a.k.a. random access). This design has Turing completeness, however, likewise many other Turing-complete systems that are not Turing machines, even if it is an inspiration for the design of a computational system.</li>
<li><em>Is there any possibility of facilitating programs design?</em> Answer: A software that translates a more human-friendly language to this executable instruction format is of possible realization. This is what is commonly called a "compiler". <strong>Compiling</strong> from C or BASIC to RESM format is a possible way to go. It would be also possible to implement <strong>other systems on top</strong> of this, for example an <strong>interpreter</strong>. That would allow to execute programs in other, possibly more human-friendly, formats. Note that today is common practice that a Central Processing Unit (CPU) is implemented using microcode (my computer use proper CPU microcode, I installed an Ubuntu Linux package for this), so this is a <strong>very common and successfully tested way to build on top on microcode</strong> systems (the RESM code could be considered <strong>microcode</strong> so this discourse applies, <strong>building higher level on low-level</strong> or in this case <strong>very very low-level</strong>).</li>
<li><em>Is there any possibility to speed up the execution of the programs in this system?</em> Answer: The <strong>clock frequency</strong> can be a factor in the speed of the circuit (more instructions per second). Another factor is the <strong>rewriting of the programs</strong> to speed up (e.g. less instructions to execute a task). Another speed factor is the parallelization, the use of many of these circuits in parallel. The program would be "spread over" many of this circuits, many cores. The circuits are possibly synchronized (they would use the same phase timing signals), and keeping them in sync is facilitated by the same time requirement for each instruction in each "core" (<strong>multi-core design</strong>). An FPGA or an ASIC could be used to physically implement this "many micro-cores" design. The FPGA would be programmed using the native and possibly closed tools, but <em><strong>the resulting circuitry could be programmed using RESM microcode, a more open, well-known and free-to-use format</strong></em>. Just-In-Time (<strong>JIT</strong>) code production and reconfigurable (<strong>re-programmable on the field</strong>) computing style are quite well suited for these designs. These reconfigurability using a low-level language could be labeled as "<strong>low-level reconfigurability</strong>" (on FPGA or ASIC). That would allow run-time optimizations, besides static compile time optimizations. The cores would communicate using I/O ports (i.e. specific dedicated memory addresses, like the I/O of the single-core version).</li>
<li><em>Do you foresee other uses of this design?</em> Answer: A possible use is in the context of software synthesis: the program format allows <strong>micro-mutations</strong>. This could be paired well, in my estimations, with <strong>genetic programming</strong>, even if making the coupling work may require addition insights.</li>
<li><em>How about creating or presenting it to communities?</em> Answer: I like the idea of presenting a VHDL/Verilog design to <a href="https://twitter.com/librecores" target="_blank">LibreCores</a>. Also <strong>crowd-funding</strong> some project and/or research based on it could be another way to go, possibly.</li>
</ul>
